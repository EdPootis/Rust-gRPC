# Advanced Programming Module 8
**Nama: Edmond Christian**<br>
**NPM: 2306208363**


### Reflection
1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
- Perbedaan utama dari ketiga protokol adalah frekuensi *request* dan *response* yang terjadi. Unary memiliki interaksi *server*-*client* di mana *client* memberikan sebuah *request* dan server mengembalikan sebuah *response*. Server streaming memiliki interaksi di mana *client* memberikan sebuah *request* dan *server* membalasnya dengan mengembalikan berbagai *response* yang di-"stream" ke client. Bi-directional streaming terjadi saat *client* dan *server* saling mengirim *request* dan *response* yang jaringannya *continuous*.
- Unary cocok digunakan saat hanya perlu sebuah *request* dan *respons* misalnya saat autentikasi. Server streaming cocok digunakan saat *client* ingin membutuhkan *response* dari server secara *continuous* contohnya saat melihat *update* cuaca. Bi-directional streaming digunakan saat diperlukan banyak *request* dan *response* pada jaringan yang *continuous* contohnya bermain game online dan chat.
2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
- Pada authentication, yang harus diperhatikan adalah memastikan hanya client yang sudah diverifikasi/sebenarnya yang dapat berkomunikasi dengan server. Pada Rust, terdapat *libraries* seperti `tonic` yang mendukung TLS untuk komunikasi yang *secure*. Dengan *mutual TLS* (mLTS) *client* dan *server* bisa saling memverifikasi identitas.
- Pada authorization, yang harus diperhatikan adalah memastikan untuk membatasi aktivitas/wewenang yang dapat dilakukan oleh *client* yang sudah diautentikasi. Pada Rust, dapat digunakan RBAC (*role-based access control*) atau ABAC (*attribute-based access control*). Selain itu juga dapat dilakukan validasi *permission* *client* dari token JWT.
- Pada data encryption, yang harus diperhatikan adalah memastikan data yang di dalam *transit* menggunakan gRPC terenkripsi dengan kuat. Pada gRPC komunikasi menggunakan HTTP/2 yang sudah lebih aman dari HTTP/1.1, tetapi selain itu juga perlu digunakan TLS agar data yang ditransfer lebih terenkripsi.
3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
- Isu yang mungkin terjadi adalah mengenai sinkronisasi, *response time*, dan keamanan. Pada Rust, kita harus mengatur agar misalnya pada aplikasi *chat*, teks pesan yang dikirim sinkron antara *server* dan berbagai *client* yang berkaitan. Akibatnya harus dibuat sistem yang *concurrent* dan *asynchronous*. Lalu untuk mencegah *response time* dari *server* yang lambat maka harus direncanakan *flow control* dari aplikasi chat yang menyeimbangkan performa *server* dan kenyamanan pengguna. Yang terakhir, bidirectional streaming harus dipastikan aman dan terenkripsi karena berisi pertukaran data yang *continuous* dan sekalinya terjadi kebocoran maka akan fatal.
4. What are the advantages and disadvantages of using the `tokio_stream::wrappers::ReceiverStream` for streaming responses in Rust gRPC services?
- Kelebihannya adalah integrasi yang mudah dengan `tokio::mpsc` dan cocok jika ingin digunakan di *service* Rust yang *asynchronous*. Integrasi dengan `tokio::mpsc` mudah karena dengan `ReceiverStream` *channel* dari `tokio::mpsc::Receiver<T>` dapat langsung dikonversikan menjadi stream yang *compatible* dengan gRPC. Lalu, *streaming* dengan `Receiver` dapat dilakukan secara *asynchronous* sehingga mendukung *concurrency*. Kekurangannya adalah perlunya konfigurasi yang lebih banyak karena *buffering* pada stream dapat berukuran besar sehingga menyebabkan penggunaan memori yang tinggi. Lalu ada kemungkinan saat *channel* ditutup tiba-tiba, stream langsung selesai sehingga pengiriman metadata atau error bisa tidak selesai.
5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
- Beberapa cara untuk mengstruktur kode Rust gRPC agar mendukung modularitas, *maintainability*, dan *extensibility* adalah untuk memisahkan berbagai *layer*, contohnya modul proto yang berisi file .proto dan layer source yang berisi logic dari aplikasi, yang dapat dibagi lagi berdasarkan fungsi modul atau isinya (contohnya modul model dan *service*). Lalu gRPC dapat hanya menggunakan abstraksi dari suatu *trait* *service* sehingga memudahkan *testing*, penambahan kode, dll. Dengan beberapa cara tersebut, kode akan lebih rapih dan terstruktur sehingga memudahkan pemeliharaan/*maintainability* dan pengembangan/*extensibility* untuk kedepannya.
6. In the *MyPaymentService* implementation, what additional steps might be necessary to handle more complex payment processing logic?
- Ada beberapa hal yang dapat ditambahkan pada `MyPaymentService`. Yang pertama adalah validasi input, karena pada aplikasi yang sebenarnya pembayaran pasti akan berkaitan dengan uang dan identitas *client* yang bersifat sensitif dan harus dipastikan kebenaran setiap prosesnya. Kedua, autentikasi dan otorisasi juga diperlukan pada sebuah *service* untuk pembayaran. Ketiga, tambahkan integrasi dengan berbagai metode pembayaran dan juga database untuk menyimpan catatan transaksi yang terjadi. Keempat, buat sistem *logging* yang mencatat setiap kegiatan yang berkaitan dengan *service* pembayaran.
7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
- Penggunaan gRPC memengaruhi arsitektur dan desain sistem terdistribusi dengan memperkenalkan protokol komunikasi yang efisien, terstruktur, dan berbasis kontrak. Karena format data yang menggunakan Protobuf yang meng-*encode* data dalam *binary*, komunikasi yang dilakukan menjadi lebih ringan dan cepat dibandingkan misalkan REST yang menggunakan JSON. Akibatnya, desain *microservice* yang membutuhkan banyak komunikasi antar *service*nya dapat memanfaatkan gRPC untuk berkomunikasi. Selain itu, gRPC mendukung *interoperability*  antar bahasa pemrograman/platform selama memenuhi kontrak/format yang telah dikonfigurasikan yang lebih lanjut mendukung desain sistem terdistribusi.
8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
- Kelebihan dari HTTP/2 yang pertama adalah adanya fitur *multiplexing* yang memungkinkan beberapa *request* dan *response* dalam 1 jaringan secara paralel dan *continuous* yang membuat komunikasi lebih efisien dan cepat. Yang kedua adalah protokol yang berbasis *binary* dan bukan teks sepeti HTTP/1.1. Hal ini membuat HTTP/2 lebih efisien dan cepat lagi dibandingkan HTTP/1.1. Yang ketiga adalah *header compression* yang mengkompresi *header* sehingga mengurangi *overhead* yang terutama berguna bagi API yang sering memberikan *request* ataupun *response* dengan header yang sama/mirip. Kekurangan dari HTTP/2 dibandingkan HTTP/1.1 atau WebSocket adalah HTTP/2 lebih kompleks untuk diimplementasikan dan di-*debug* karena fitur-fiturnya. Lalu ada juga masalah *compatibility* penggunaan HTTP/2 yang belum sepenuhnya mendukung penggunaan HTTP/2 atau gRPC.
9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
- Pada REST APIs, model *request-response* berjalan secara satu arah, di mana *client* membuat *request* dan kemudian menunggu *response* dari server sebelum memutuskan jaringan. Karena itu, komunikasi REST APIs lebih cocok untuk komunikasi yang tidak *real-time*. Sementara, *bidirectional streaming* pada gRPC memungkinkan komunikasi *client* dan *server* yang *continuous* dan *asynchronous* selama jaringan/*channel* belum ditutup. Karena itu, maka komunikasinya memiliki *responsiveness* yang lebih tinggi dari REST API dan cocok untuk digunakan pada komunikasi secara *real-time* atau memerlukan pembaruan yang frekuen/dalam waktu cepat.
10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
- Pada gRPC, penggunaan Protocol Buffers mendefinisikan struktur/format data secara eksplisit melalui file `.proto`, sehingga tipe data dan *field* yang digunakan sudah tervalidasi sehingga mengurangi risiko kesalahan/error. Sementara dengan JSON yang fleksibel, format datanya bisa tidak konsisten sehingga membutuhkan validasi tambahan pada sisi aplikasi. Penggunaan Protocol Buffers juga meng-*encode* data dalam format *binary* yang dibandingkan JSON yang berbasis teks komunikasi sehingga keperluan *bandwidth* lebih rendah yang menyebabkan latensi lebih rendah. Tetapi format JSON yang berbasis teks dan fleksibel juga memudahkan proses *debug* komunikasi REST APIs, dibandingkan gRPC yang datanya dalam format *binary*. Selain itu, karena adanya *contract* dalam Protocol Buffer, maka menambahkan kompleksitas kode dan diperlukan konfigurasi lebih banyak dalam menggunakan gRPC dibandingkan REST API yang lebih fleksibel dan lebih cepat dalam pengembangannya. 